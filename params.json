{"name":"Rxbluetooth","tagline":"Android reactive bluetooth","body":"RxBluetooth\r\n===========\r\n\r\n[![Build Status](https://travis-ci.org/IvBaranov/RxBluetooth.svg)](https://travis-ci.org/IvBaranov/RxBluetooth)\r\n\r\nAndroid reactive bluetooth library. RxBluetooth is in early-stage. There is a lot of missing stuff. Feel free to contribute.\r\n\r\nUsage\r\n-----\r\n\r\n1. Declare permissions:\r\n   ```xml\r\n   <uses-permission android:name=\"android.permission.BLUETOOTH\" />\r\n   <uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" />\r\n   ```\r\n\r\n2. Create `RxBluetooth` instance.\r\n\r\n3. Check if bluetooth is currently enabled and ready for use:\r\n   ```java\r\n   if  (!rxBluetooth.isBluetoothAvailable()) {\r\n      // to enable blutooth via startActivityForResult()\r\n      rxBluetooth.enableBluetooth(this, REQUEST_ENABLE_BT);\r\n   }\r\n   ```\r\n\r\n4. Have fun.\r\n5. Make sure you are unsubscribing and stopping discovery `OnDestroy()`:\r\n\r\n   ```java\r\n   if (rxBluetooth != null) {\r\n         rxBluetooth.cancelDiscovery();\r\n       }\r\n   unsubscribe(rxBluetoothSubscription);\r\n   ```\r\n\r\n##### Observing devices\r\n```java\r\nrxBluetooth.observeDevices()\r\n      .observeOn(AndroidSchedulers.mainThread())\r\n      .subscribeOn(Schedulers.io())\r\n      .subscribe(new Action1<BluetoothDevice>() {\r\n        @Override public void call(BluetoothDevice bluetoothDevice) {\r\n          //\r\n        }\r\n      });\r\n```\r\n\r\n##### Observing discovery state\r\n\r\nTo observe just `ACTION_DISCOVERY_STARTED`:\r\n\r\n```java\r\nrxBluetooth.observeDiscovery()\r\n      .observeOn(AndroidSchedulers.mainThread())\r\n      .subscribeOn(Schedulers.io())\r\n      .filter(Action.isEqualTo(BluetoothAdapter.ACTION_DISCOVERY_STARTED))\r\n      .subscribe(new Action1<String>() {\r\n        @Override public void call(String action) {\r\n          //\r\n        }\r\n      });\r\n```\r\n\r\nTo observe both `ACTION_DISCOVERY_STARTED` and `ACTION_DISCOVERY_FINISHED`:\r\n\r\n```java\r\nrxBluetooth.observeDiscovery()\r\n      .observeOn(AndroidSchedulers.mainThread())\r\n      .subscribeOn(Schedulers.io())\r\n      .filter(Action.isEqualTo(BluetoothAdapter.ACTION_DISCOVERY_STARTED, BluetoothAdapter.ACTION_DISCOVERY_FINISHED))\r\n      .subscribe(new Action1<String>() {\r\n        @Override public void call(String action) {\r\n          //\r\n        }\r\n      });\r\n```\r\n\r\n##### Observing bluetooth state\r\n\r\n```java\r\nrxBluetooth.observeBluetoothState()\r\n      .observeOn(AndroidSchedulers.mainThread())\r\n      .subscribeOn(Schedulers.io())\r\n      .filter(Action.isEqualTo(BluetoothAdapter.STATE_ON))\r\n      .subscribe(new Action1<Integer>() {\r\n        @Override public void call(Integer integer) {\r\n          //\r\n        }\r\n      });\r\n```\r\n\r\nYou can observe single or multiple states:\r\n```java\r\nBluetoothAdapter.STATE_OFF\r\nBluetoothAdapter.STATE_TURNING_ON\r\nBluetoothAdapter.STATE_ON\r\nBluetoothAdapter.STATE_TURNING_OFF\r\n```\r\n\r\n##### Observing scan mode\r\n\r\n```java\r\nrxBluetooth.observeScanMode()\r\n      .observeOn(AndroidSchedulers.mainThread())\r\n      .subscribeOn(Schedulers.io())\r\n      .filter(Action.isEqualTo(BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE))\r\n      .subscribe(new Action1<Integer>() {\r\n        @Override public void call(Integer integer) {\r\n          //\r\n        }\r\n      });\r\n```\r\n\r\nYou can observe single or multiple scan modes:\r\n```java\r\nBluetoothAdapter.SCAN_MODE_NONE\r\nBluetoothAdapter.SCAN_MODE_CONNECTABLE\r\nBluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE\r\n```\r\n\r\n#### Getting the profile proxy object\r\n\r\n```java\r\nrxBluetooth.observeBluetoothProfile(myProfile)\r\n      .observeOn(AndroidSchedulers.mainThread())\r\n      .subscribeOn(Schedulers.io())\r\n      .subscribe(new Action1<ServiceEvent>() {\r\n        @Override public void call(ServiceEvent serviceEvent) {\r\n          switch (serviceEvent.getState()) {\r\n           case CONNECTED:\r\n                BluetoothProfile bluetoothProfile = serviceEvent.getBluetoothProfile();\r\n                List<BluetoothDevice> devices = bluetoothProfile.getConnectedDevices();                        \r\n                for ( final BluetoothDevice dev : devices ) {\r\n                  //..\r\n                }\r\n                break;\r\n           case DISCONNECTED:\r\n                //serviceEvent.getBluetoothProfile() returns null\r\n                break;\r\n            }\r\n          }\r\n        });\r\n```\r\n\r\n`myProfile` can be one of `BluetoothProfile.HEALTH`, `BluetoothProfile.HEADSET`, `BluetoothProfile.A2DP`, `BluetoothProfile.GATT` or `BluetoothProfile.GATT_SERVER`\r\n\r\nClients should close profile proxy when they are no longer using the proxy obtained from `observeBluetoothProfile`:\r\n```java\r\nrxBluetooth.closeProfileProxy(int profile, BluetoothProfile proxy);\r\n```\r\n\r\nDownload\r\n--------\r\n```groovy\r\ncompile 'com.github.ivbaranov:rxbluetooth:0.0.5'\r\n```\r\nSnapshots of the development version are available in [Sonatype's `snapshots` repository][snapshots].\r\n\r\nContributing\r\n------------\r\nMake sure you use SquareAndroid code style. (https://github.com/square/java-code-styles)\r\n\r\nCreate a branch for each feature.\r\n\r\nDeveloped By\r\n------------\r\nIvan Baranov\r\n\r\nLicense\r\n-------\r\n\r\n```\r\nCopyright 2015 Ivan Baranov\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n   http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n```\r\n[snapshots]: https://oss.sonatype.org/content/repositories/snapshots/\r\n ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}